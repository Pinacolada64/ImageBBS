' break2.s - updated 12/4/2017
' display information (current address, stack pointer, $00, $01) when BRK encountered

' translated from compute!s fast assembler to c64list3.05:
' <http://www.commodoreserver.com/Downloads.asp>
' perhaps xa would work better:
' <http://www.floodgap.com/retrotech/xa/>

{number:10}
	sys{sym:setup}
	poke 828,0:sys 828
	end
{asm}
; 65352	      $FF48
; Main IRQ/BRK Interrupt Entry Point

; Anytime the BRK instruction is encountered or an IRQ interrupt occurs,
; this routine will be executed. The routine first saves the .A, .X,
; and .Y registers on the stack, and then tests the BRK bit of the
; status register (.P) to see if a BRK was executed.  If it was, the
; routine exits through the RAM BRK vector at 790 ($316)
setup:
	lda #<brk1
	sta $316
	lda #>brk1
	sta $317
	rts
;
brkbuf	= $c000

brk1:
	ldx #5		; counter for pulling 6 bytes of stack info
	lda #27
	sta $d011
brk2:
	pla
	sta brkbuf,x
	dex
	bpl brk2
	tsx		; pull stack pointer
	stx brkbuf+6
	sec
	lda 0		; add $00 (6510 On-Chip I/O Data Direction Register) to buffer
	sta brkbuf+7
	lda 1		; add $01 (RAM banking) to buffer
	sta brkbuf+8
	lda $df02	; add $df02 (CIA #2 Register Images) to buffer - copy of
			; $DD02	C2DDRA Data Direction Register A?
	sta brkbuf+9
	lda brkbuf+1	; get low byte of pc
	sbc #2		; subtract 2
	sta brkbuf+1	; update...
	bcs brk2a
	dec brkbuf
brk2a:
	ldy #0
brk2b:
	lda msg1,y
	beq brk2c
	jsr hex2
	iny
	jmp brk2b
brk2c:
	ldx #0
brk3:
	cpx #2
	bcc brk3a
	lda #$20	; space
	jsr hex2
brk3a:
	lda brkbuf,x
	jsr hex
	inx
	cpx #10		; printed 16 bytes?
	bne brk3	; no
	lda #$0d	; yes, output cr
	jsr hex2
	ldy #0
brk3b:
	lda msg2,y	; print 2nd message
	beq brk3c
	jsr hex2
	iny
	jmp brk3b
brk3c:
	ldy #0
brk4:
	pla
	jsr hex
	iny
; this was commented out in original code:
; adds spaces between bytes after msg2
	lda #$20	; space
	jsr hex2
; end commented out
	cpy #16
	bcc brk5
	lda #$0d
	jsr hex2
	ldy #0
brk5:
	tsx
	cpx #$ff
	bne brk4
	lda #$0d
	jsr hex2
	lda #$0d
	jsr hex2

	jmp ($a002)	; BASIC warm start vector

; original code crashes here:
; byte 2
;

hex:
	pha
	lsr
	lsr
	lsr
	lsr
	jsr hex1
	pla
hex1:
	and #$0f
	ora #$30
	cmp #$3a
	bcc hex2
	adc #$06
hex2:
	sta char
	txa
	pha
	ldx cpos
	lda char
	cmp #13
	beq hex3
hex2a:
	sta $0400,x	; output to screen mem
	lda #1
hex2b:
	sta $db00,x	; output to color mem
	inx
	stx cpos
	cpx #40
	bcc hex4
hex3:
	clc
	lda hex2a+1
	adc #40
	sta hex2a+1
	lda hex2a+2
	adc #0
	sta hex2a+2
	clc
	lda hex2b+1
	adc #40
	sta hex2b+1
	lda hex2b+2
	adc #0
	sta hex2b+2
	ldx #0
	stx cpos
hex4:
	pla
	tax
	lda char
	rts
;
cpos:
	byte 0
char:
	byte 0
;
msg1:
alpha	= $40	; for poking lowercase strings to screen, $40+1 = "a"

; Original source had no strings here, "msg1:" and "msg2:" are therefore
; placeholders until I figure out what they're supposed to say

; these 6 bytes are | these are also
; pulled off stack  | displayed by
; by this routine   | this routine
;  0 1  2  3  4  5  |
;  addr ac xr yr ?? | sp 00 01 df02?
;  033c 30 08 00 00 | f6 2f 37 00

	byte $41	; "a"
	byte $44	; "d"
	byte $44	; "d"
	byte $52	; "r"
	byte $20	; " "
	byte $41	; "a"
	byte $43	; "c"
	byte $20	; " "
	byte $58	; "x"
	byte $52	; "r"
	byte $20	; " "
	byte $59	; "y"
	byte $52	; "r"
	byte $20	; " "
	byte 63		; "?"
	byte 63		; "?"
	byte $20	; " "
	byte $53	; "s"
	byte $50	; "p"
	byte $20	; " "
	byte $30	; "0"
	byte $30	; "0"
	byte $20	; " "
	byte $30	; "0"
	byte $31	; "1"
	byte $20	; " "
	byte $44	; "d"
	byte $46	; "f"
	byte $30	; "0"
	byte $32	; "2"
	byte 63		; "?"
	byte 13		; <return>
	byte 0		; <null>

msg2:
	byte $4d	; "m"
	byte $53	; "s"
	byte $47	; "g"
	byte $32	; "2"
	byte 58		; ":"
	byte 13		; <return>
	byte 0		; <null>
{endasm}
